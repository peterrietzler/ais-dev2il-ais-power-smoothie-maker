# AIS DEV2IL üòà Power Smoothie Maker

Welcome to the AIS Power Smoothie Maker exercise! Ready to blend up some Python skills? This exercise will guide you through a simple project, showing you why dependency management is crucial and how `uv` can make your life easier with zero-configuration environments.

## Zero Configuration Using `uv`

üõ† Tools You'll Need
- Your terminal
- PyCharm

### Step 1: Get your personal copy of the smoothie maker repository (Fork & Clone)

First, you need to create your own copy of this repository on GitHub. This is called a "fork". A fork is a personal copy 
of another user's repository that lives on your account. Forks allow you to freely experiment with changes without 
affecting the original project.

- Go to the repository page: https://github.com/peterrietzler/ais-dev2il-ais-power-smoothie-maker
- Click the __Fork__ button in the top-right corner. Make sure that your fork contains all branches, not just the `main` branch.
- Clone your fork to your local machine.

### Step 2: Let's make our first smoothie!

Let's try to run the smoothie maker script.

```bash
python main.py
```

You will see an error like this:

üí•BOOM! It crashes!
```
Traceback (most recent call last):
  File "main.py", line 1, in <module>
    from rich.console import Console
ModuleNotFoundError: No module named 'rich'
```

This error means that the `rich` library, which our script depends on, is not installed in your Python environment, but it's
required to run the script. You could now try to install the `rich` library manually, but then you would need to start entering
configuration hell. 

### Step 3: Introducing `uv`

To solve this, we will use `uv`. 
`uv` is an extremely fast Python package installer and resolver. 
It's a single binary that can be used to create virtual environments and manage 
project dependencies, similar to `pip` and `venv` combined, but much faster.

#### Install `uv`

https://docs.astral.sh/uv/#installation

#### Initialize the Project with `uv`

Now, let's start to manage our poject wiht `uv`. In our project root directory,
run

```bash
uv init
```

üí°At this point in time, we are going to start inspecting and changing code. You should therefore
now open the project in PyCharm. IDEs like PyCharm or Visual Studio Code will automatically detect 
that you are using `uv` and will automatically configure itself to e.g. use the virtual environment 
created by `uv` for your project.

‚ö†Ô∏èIf you already used PyCharm up to this point, quit it, delete the `.idea` directory in your project directory
and open the project again in PyCharm.

`uv` created a few files in your project directory. Let's briefly understand what they are:

- **`pyproject.toml`**: The configuration file for your Python. It contains metadata about your project and its required environment.
You can either directly edit this file or manage it via `uv` commands (more on this later).
- **`.python-version`**: A file that specifies the Python version for this project. Do not edit this file. It's managed by `uv`. 
- **`uv.lock`**: This file contains the exact versions of all your dependencies. This ensures that anyone who sets up the project 
will have the exact same versions, creating a reproducible environment. Do not edit this file. It's managed by `uv`.


#### Add the `rich` Dependency

Next, we need to add the `rich` library to our project.

```bash
uv add rich
```

This command will download and install the `rich` library and also add it as a dependency 
to your `pyproject.toml` file. `uv` automatically manages the virtual environment for your
project in the `.venv` directory. 

Have a look at the `pyproject.toml` file to see that the `rich` library is now listed as a dependency.

üí°If you are more comfortable with editing the `pyproject.toml` file directly, you can also do that. 
You could have simply added the `rich` dependency to the `dependencies` section of the file. If you do 
so you will need to e.g. run `uv sync` to install the new dependency.

####  Let's make our first smoothie! (Again)

Now that we have our dependency installed, let's run the script again, 
but this time using `uv`. It is going to take care for you that your project's 
environment is used correctly.

```bash
uv run main.py
```

‚úÖVoila! The smoothie maker should now run successfully and print a 
colorful message to your terminal.

### Step 4 - Let your team mate prepare a smoothie!

Now that you have a working setup, it's time to share your work.

**Commit and Push Your Changes:**
    Add the new files to git, commit them, and push them to your forked repository on GitHub.

ü§ù **Partner Up!**
    Your partner can now clone your repository and just execute `uv run main.py`. `uv` will automatically set up the environment 
    and then prepare a smoothie.


### Step 5 - Let's have some fun while waiting for our smoothie!

To show how easy it is to manage our environment, one partner will now add a new feature: telling a joke while the smoothie is being prepared.

**Add the `pyjokes` Dependency:**

`pyjokes` is a python library for that generateds jokes for programmers. Let's add it with `uv`:
    
```bash
uv add pyjokes
```

`uv` will download the library and add it to your `pyproject.toml` and `uv.lock` files.

**Add the Joke Code:**

Open `main.py` and add the following code right after the "Starting to make" output:

```python
import pyjokes
joke = pyjokes.get_joke()
console.print(f"[bold cyan]Let me enlighten you with a joke while you wait: {joke}[/bold cyan]\n")
```

**And prepare another smoothie:**
```bash
uv run main.py
``` 

‚úÖ See how it works! You have a smoothie and a joke.

**Commit and Push:**
Commit and push your changes so your partner can get the new feature.

ü§ù **Partner Up (Again)!**
The second partner can now pull the changes from the repository. Then, he can simply run:
```bash
uv run main.py
```
`uv` will see the changes in the `uv.lock` file, automatically install the new `pyjokes` dependency, and run the script. Zero manual configuration needed!

### üèÜ Summary Cheat Sheet

| Command | Description |
|---|---|
| `uv init` | Initializes a new project, creating `pyproject.toml`. |
| `uv add <package>` | Adds a dependency to the project and installs it. |
| `uv remove <package>` | Removes a dependency from the project. |
| `uv run ...` | Runs a command within the project's managed environment. |
| `uv sync` | Installs dependencies from `uv.lock` to exactly recreate the environment. |


| File              | What it does                                                                    |
|-------------------|---------------------------------------------------------------------------------|
| `pyproject.toml`  | Lists what your project needs (e.g. the python version or compatible libraries) |
| `uv.lock`         | Remembers the exact version of every tiny detail so it's identical for everyone |
| `.python-version` | Tells `uv` which Python version to use                                          |
| `.venv`           | Contains the `uv` managed Pytyhon virtual environment                           |




### üöÄ Level Up

Finished early? Put your `uv` skills to the next level with these "Pro" moves.


#### `uv tree`
This command displays the dependency tree of your project. It's incredibly useful for a few reasons:
- **Visibility**: See exactly which packages are included and which package brought them in.
- **Debugging**: Helps you track down where a specific dependency is coming from, which is a lifesaver for resolving version conflicts.

Try it out:
```bash
uv tree
```

## Unit Testing with pytest

Unit testing is a way to check that your code works as expected. In Python, the most popular tool for this is `pytest`.

### What is pytest?

[pytest](https://docs.pytest.org/) is a testing framework for Python that makes it easy to write automated tests.
It helps you check that your code behaves as intended and makes it easy to spot bugs early.

### Step 1 - Installing pytest

Install pytest as a development dependency using `uv`:

```bash
uv add --dev pytest
```

üí°We add pytest as a **development dependency** because it is only needed during development
and testing, not when running the application in production. This keeps your production
environment clean and focused only on what is necessary to run your code. After adding pytest, open your `pyproject.toml` file and look for a `[dependency-groups]` section.
You should see `pytest` listed there. This helps you understand which packages are required for
development and testing, separate from your main application dependencies.

### Step 2 - Creating a Test File

Test files should be named starting with `test_`. This naming convention allows `pytest` to automatically
discover your tests.

Create a new file in your project root:

```
test_main.py
```

### Step 3 - Writing a Test for `get_ingredients`

Test functions should also start with `test_`. Here is an example test for the `get_ingredients` function:

```python
import tempfile
from pathlib import Path
from main import get_ingredients

def test_get_ingredients():
    """get_ingredients successfully returns ingredients from the file"""
    # Given: a recipe file with some ingredients
    content = "Apple\nBanana\nOrange\n"
    with tempfile.TemporaryDirectory() as tmp_path:
        recipe_file = Path(tmp_path) / "recipe.txt"
        recipe_file.write_text(content)
        expected = ["Apple", "Banana", "Orange"]
        # When: we call get_ingredients
        result = get_ingredients(recipe_file)
        # Then: we get the expected list of ingredients
        assert result == expected
```

üí°The function name and docstring describe exactly what is being tested. 
A good test is like a specification: choose names and descriptions carefully so others understand what the code should do.
Also the test code should read like a short, clear story. Use the Given-When-Then structure to 
make your tests easy to understand.


### Step 4 - Running Your Tests

**With uv:**
```bash
uv run pytest
```

**With PyCharm:**
- Right-click the test file or function and select to run Python tests.
- You might need to configure PyCharm to use `pytest` as the test runner in _Preferences > Python > Tools > Integrated Tools > Default test runner: pytest_

### Step 5 - See what happens when things change

Let's add another test for `get_ingredients` to check its behavior when the file does not exist:

```python
def test_get_ingredients_file_does_not_exist():
    """get_ingredients returns an empty list of ingredients if the file does not exist"""
    # Given: a path to a file that does not exist
    with tempfile.TemporaryDirectory() as tmp_path:
        non_existent_file = Path(tmp_path) / "non_existent.txt"
        # When: we call get_ingredients
        result = get_ingredients(non_existent_file)
        # Then: we get an empty list
        assert result == []
```

Add this test to your test file. Run your tests to make sure everything is green and works as expected.

Now, let's change the implementation of `get_ingredients` in `main.py` to raise an error if the file does not exist:

```python
def get_ingredients(recipe_file: Path) -> list[str]:
    if not recipe_file.exists():
        raise FileNotFoundError(f"The file {recipe_file} does not exist.")
    # ...existing code...
```

Run your tests again. üí• **BOOM!** You get immediate feedback that something is broken. The contract of the function was to return an empty list if the file does not exist, not to fail! This might break code in other places and change existing behavior.

Revert your change to the implementation until all tests are green again. This is how tests help you catch breaking changes early and keep your code reliable.

### üöÄ Level Up

Finished early? Put your testing skills to the next level with these "Pro" moves.

#### Generate a nice HTML test report

Tests are great. A nice report is even better!
Use the `pytest-html` plugin to generate a HTML report for your tests.

1.  Add the plugin: `uv add --dev pytest-html`
2.  Run the tests with the report option: `uv run pytest --html=report.html`
3.  Open `report.html` in your browser.

#### Use Test Fixtures

Test fixtures are functions that run before (and sometimes after) your tests to set up the environment.
Check out the [pytest fixture documentation](https://docs.pytest.org/en/stable/explanation/fixtures.html) to learn more.

`pytest` comes with many built-in fixtures. One of them helps us to get rid of the boilerplate code
for creating temporary directories.

The `tmp_path` fixture provides a temporary directory unique to the test invocation.

**Task:** Refactor your `test_get_ingredients` to use the `tmp_path` fixture.

It should look something like this:

```python
def test_get_ingredients(tmp_path):
    # Given: a recipe file with ingredients
    content = "Apple\nBanana\nOrange"
    recipe_file = tmp_path / "my_smoothie.txt"
    recipe_file.write_text(content)

    # When: get_ingredients is called
    result = get_ingredients(recipe_file)

    # Then: it returns the list of ingredients
    expected = ["Apple", "Banana", "Orange"]
    assert result == expected
```

#### Design for Testability

Look at the `make_smoothie` function. It is not very test friendly.
Can you identify why?

<details>
<summary>üëÄ Show Reasons</summary>

1.  **Side Effects 1**: It prints directly to the console using `rich.Console` and `print`. To test this, we would need to capture the standard output, which is cumbersome.
2.  **Dependencies**: It instantiates `Console()` inside the function. We cannot easily swap it out for a mock or a dummy to verify what is being printed.
3.  **Side Effects 2**: Your test calls the function `pyjokes.get_joke`. "E.T. is calling home" (it will do an internet call). Your test can't be run without internet connection.
3.  **Time**: It uses `time.sleep()`. This makes tests slow. Tests should be fast!
</details>

**Challenge 1: A cumbersome test is better than no test at all**

Let's consider that we have to take `make_smoothie` as it is, but we still want to ensure that it properly 
outputs the ingredients.

Try to write a test for `make_smoothie` that calls the function and verifies that ingredients are printed out.
*   **Hint**: You can use the [`capsys` fixture](https://docs.pytest.org/en/stable/builtin.html) from pytest to capture standard output.  

<details>
<summary>üëÄ Show Solution</summary>

```python
def test_make_smoothie_prints_added_ingredients(tmp_path, capsys):
  """make_smoothie prints all ingredients that were added to the smoothie to the console"""
  # Given
  recipe_file = tmp_path / "test.txt"
  recipe_file.write_text("Apple\nBanana\n")
  
  # When: we make a smoothie
  make_smoothie(recipe_file)

  # Then: all added ingredients are printed to the console
  captured = capsys.readouterr()
  assert "Added Apple" in captured.out
  assert "Added Banana" in captured.out
```

</details>

**Challenge 2: Refactor the function for testability by injecting dependencies**

Adaptation for better testability often involves dependency injection.
Instead of creating the `Console` inside the function, pass it as an argument!
    
Change the signature to:
```python
def make_smoothie(recipe_file: Path, console: Console) -> list[str]:
    # remove console = Console() line
    # ... use the passed console ...
```

Now that we can inject the dependency, we can pass a special console that records what is printed!

```python
from rich.console import Console

def test_make_smoothie_prints_added_ingredients(tmp_path):
  """make_smoothie prints all ingredients that were added to the smoothie to the console"""
  
  # Given: a recipe file
  recipe_file = tmp_path / "test.txt"
  recipe_file.write_text("Apple\nBanana\n")
  
  # When: we make a smoothie
  console = Console(record=True)
  make_smoothie(recipe_file, console)
  
  # Then: all added ingredients are printed to the console
  text_output = console.export_text()
  assert "Added Apple" in text_output
  assert "Added Banana" in text_output
```

**Challenge 3: Mocking Dependencies**

We solved the console output problem, but we still have `pyjokes.get_joke()`.

**The Problem:**
1.  **Non-determinism**: The function returns a random joke. We don't know what text to expect in our assertions.
2.  **External Dependencies**: As mentioned, if this library were to fetch jokes from the internet, our tests would fail offline.

**What is Mocking?**
Mocking is a technique used in unit testing to replace real objects or functions with "fake" versions (mocks) that simulate the behavior of the real ones. This allows you to eliminate non-determinism and isolate the code you are testing.

Let's write a test `test_make_smoothie_prints_a_joke` that mocks `pyjokes.get_joke` so it always returns a known string instead of "calling home".
We are going to use the [`monkeypatch` fixture](https://docs.pytest.org/en/stable/builtin.html) from `pytest`. It allows you to safely replace functions for the duration of a test.

```python
import pyjokes

def test_make_smoothie_prints_a_joke(tmp_path, monkeypatch):
    """make_smoothie prints a joke"""
    
    # Given: a recipe file
    recipe_file = tmp_path / "recipe.txt"
    recipe_file.write_text("Mango\n")
    # Mocking: Replace pyjokes.get_joke with a lambda that returns a fixed string
    test_joke = "A mock walks into a bar. The bartender asks, 'What can I get you?' The mock returns None."
    monkeypatch.setattr(pyjokes, "get_joke", lambda: "A mock walks into a bar. The bartender asks, 'What can I get you?' The mock returns None.")

    # When: we make a smoothie
    console = Console(record=True)
    make_smoothie(recipe_file, console)

    # Then: a joke is told
    output = console.export_text()
    assert "The mock returns None" in output
```
